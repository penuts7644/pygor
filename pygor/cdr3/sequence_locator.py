# Pygor is part of the IGoR (Inference and Generation of Repertoires) software.
# Pygor Python package can be used to post process files generated by IGoR.
# Copyright (C) 2018 Quentin Marcou & Wout van Helvoirt

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


"""SequenceLocator class for locating the CDR3 sequences in the alignment."""


import pandas

from pygor.util.processing import multiprocess_array


class SequenceLocator(object):
    """Class for locating CDR3 sequences within the given nucleotide alignment.

    Parameters
    ----------
    seqs : pandas.DataFrame
        A dataframe with indices and sequences. The indices need to align with
        the ones in v_align and j_align dataframes.
    v_align : pandas.DataFrame
        Dataframe according to IGoR alignment option output file specs (look at
        documentation).
    j_align : pandas.DataFrame
        Dataframe according to IGoR alignment option output file specs (look at
        documentation).

    Methods
    -------
    get_cdr3_sequences(conserved_v_motif_indices, conserved_j_motif_indices)
        Returns the indices dictionarys for each of the given motifs in the
        given list.

    Notes
    -----
        This class tries to follow IGoR CSV formatting standard for the
        outputed CDR3 sequence files.

    """
    def __init__(self, seqs, v_align, j_align):
        super(SequenceLocator, self).__init__()
        self.seqs = seqs
        self.v_align = v_align
        self.j_align = j_align

    @staticmethod
    def _find_cdr3_sequences(args):
        """Find CDR3's using provided alignments and conserved motifs indices.

        This function finds the CDR3 sequences inside a given sequence by using
        the V and J alignments from the IGoR software and the corresponding
        conserved V and J motif indices.

        Parameters
        ----------
        args : list
            The arguments from the multiprocess_array function. Consists of an
            list and additional kwargs containing pandas.DataFrame objects for
            IGoR sequences, V/J IGoR alignments and V/J motif indices.

        Returns
        -------
        pandas.DataFrame
            Containing sequence index values ('seq_index') from the input
            sequences followed by the CDR3 sequence ('sequence').

        """
        # Collect the kwargs arguments the arguments and pandas.DataFrame.
        ary, kwargs = args
        v_align = kwargs["v_align"]
        j_align = kwargs["j_align"]
        v_motif_indices = kwargs["v_motif"]
        j_motif_indices = kwargs["j_motif"]
        cdr3_seqs = pandas.DataFrame(columns=['seq_index', 'length', 'cdr3_offset',
                                              'v_score', 'j_score', 'sequence'])

        # Iterate over the rows in the dataframe.
        for _, row in ary.iterrows():

            # For both V/J, collect the row where the seq_index value equals the
            # one in V/J alignment.
            v_matches = v_align.loc[v_align['seq_index'] == row['seq_index']]
            v_matches.reset_index(drop=True, inplace=True)
            j_matches = j_align.loc[j_align['seq_index'] == row['seq_index']]
            j_matches.reset_index(drop=True, inplace=True)

            # Make sure that the match tables for V and J are not empty.
            if v_matches.empty or j_matches.empty:
                continue

            for _, v_match in v_matches.iterrows():

                # Make sure that the match tables for V contain the gene string.
                if v_match['gene_name'] not in v_motif_indices['gene'].values:
                    continue

                # Combine the offset value with the start index from the motif for the V gene.
                possible_v_motif_indices = []
                for _, v_anchor in v_motif_indices[v_motif_indices['gene'] == v_match['gene_name']].iterrows():
                    possible_v_motif_indices.append(v_match['offset'] + v_anchor['anchor_index'])

                for _, j_match in j_matches.iterrows():

                    # Make sure that the match tables for J contain the gene string.
                    if j_match['gene_name'] not in j_motif_indices['gene'].values:
                        continue

                    # Combine the offset value with the start index from the motif for the J gene.
                    possible_j_motif_indices = []
                    for _, j_anchor in j_motif_indices[j_motif_indices['gene'] == j_match['gene_name']].iterrows():
                        possible_j_motif_indices.append(j_match['offset'] + j_anchor['anchor_index'])

                    for v_index in possible_v_motif_indices:
                        for j_index in possible_j_motif_indices:

                            # The end of the v motif can not overlap with the start of the j motif.
                            if v_index + 3 >= j_index:
                                continue

                            # Create the CDR3 sequence and append to dataframe.
                            end_seq = row['sequence'][v_index:j_index + 3]
                            cdr3_seqs = cdr3_seqs.append({
                                'seq_index': row['seq_index'],
                                'length': len(end_seq),
                                'cdr3_offset': v_index,
                                'v_score': v_match['score'],
                                'j_score': j_match['score'],
                                'sequence': end_seq,
                            }, ignore_index=True)
        return cdr3_seqs


    def get_cdr3_sequences(self, conserved_v_motif_indices, conserved_j_motif_indices):
        """Collect CDR3's using provided alignments and conserved motifs indices.

        Parameters
        ----------
        conserved_v_motif_indices : pandas.DataFrame
            A dataframe containing the conserved motif indices for the V gene.
        conserved_j_motif_indices : pandas.DataFrame
            A dataframe containing the conserved motif indices for the J gene.

        Returns
        -------
        pandas.DataFrame
            Containing columns with sequence index - 'seq_index' and CDR3
            sequences - 'sequence'.

        Notes
        -----
            This function uses the class its indexed sequences as
            pandas.DataFrame as well as the  V and J alignment dataframes.
            These dataframes are based on the output from IGoR index and
            alignment options respecitively.
            This function uses the MAX_THREADS variable for multiprocessing.

        """
        # Perform the multiprocessing task.
        result = multiprocess_array(ary=self.seqs,
                                    func=self._find_cdr3_sequences,
                                    v_align=self.v_align,
                                    j_align=self.j_align,
                                    v_motif=conserved_v_motif_indices,
                                    j_motif=conserved_j_motif_indices)
        result = pandas.concat(result, axis=0).reset_index(drop=True)
        result.sort_values(['v_score', 'j_score'], ascending=False, inplace=True)
        result.drop_duplicates(['seq_index', 'sequence', 'cdr3_offset', 'length'], inplace=True)
        return result


def main():
    """Function to be called when file executed via terminal."""
    print(__doc__)


if __name__ == "__main__":
    main()

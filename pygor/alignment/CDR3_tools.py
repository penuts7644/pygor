# Pygor is part of the IGoR (Inference and Generation of Repertoires) software.
# Pygor Python package can be used to post process files generated by IGoR.
# Copyright (C) 2018 Quentin Marcou & Wout van Helvoirt

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import numpy
import pylab


def find_seq_CDR3(sequence_index, sequence, v_aligns, j_aligns,
                  conserved_V_motif_index, conserved_J_motif_index):
    """Returns the sequence CDR3 based on provided alignments and conserved
    motifs indices.

    ADDED NOTES FOR WOUT:
        sequence_index, sequence are from output files IGoR from pandas dataframe
        v_aligns, j_aligns are both pandas dataframes

    """
    # print(sequence)
    # print(sequence_index)
    # Check whether the motif was found for the aligned gene if not return None as CDR3 sequence
    seq_v_align = v_aligns[v_aligns.seq_index == sequence_index]
    seq_v_align = seq_v_align.reset_index(drop=True)

    if seq_v_align.empty:
        return None
    # return "noValign"

    # print(seq_v_align)
    if not conserved_V_motif_index.has_key(seq_v_align.at[0, 'gene_name']):
        return None
    # return "nomotifV"

    seq_j_align = j_aligns[j_aligns.seq_index == sequence_index]
    seq_j_align = seq_j_align.reset_index(drop=True)

    if seq_j_align.empty:
        return None
    # return "noJalign"

    # print(seq_j_align)
    if not conserved_J_motif_index.has_key(seq_j_align.at[0, 'gene_name']):
        return None
    # return "nomotifJ"

    # Get the CDR3 substr including 3nt base of the motifs
    # Get first approximation based on the offset
    v_motif_index = seq_v_align.at[0, 'offset'] + conserved_V_motif_index[
        seq_v_align.at[0, 'gene_name']]
    j_motif_index = seq_j_align.at[0, 'offset'] + conserved_J_motif_index[
        seq_j_align.at[0, 'gene_name']]
    # print(v_motif_index)
    # print(j_motif_index)

    # Look for insertions in the left part of the alignment
    # print(type(seq_v_align.at[0,'insertions']))
    # print(asarray(seq_j_align.at[0,'insertions']))
    # print((asarray(seq_v_align.at[0,'insertions'])<v_motif_index))
    # print((asarray(seq_j_align.at[0,'insertions'])<j_motif_index))
    #        if len(seq_v_align.at[0,'insertions'])!=0:
    #            v_motif_index+=sum((numpy.asarray(seq_v_align.at[0,'insertions'])<v_motif_index))
    #        if len(seq_j_align.at[0,'insertions'])!=0:
    #            j_motif_index+=sum((numpy.asarray(seq_j_align.at[0,'insertions'])<j_motif_index))
    #        #print(v_motif_index)
    #        #print(j_motif_index)
    #        #Look for deletions in the left part of the alignment
    #        #what would happen if a nucleotide of the motif is deleted?
    #        if len(seq_v_align.at[0,'deletions'])!=0:
    #            v_motif_index -= sum((numpy.asarray(seq_v_align.at[0,'deletions'])<conserved_V_motif_index[seq_v_align.at[0,'gene_name']]))
    #        if len(seq_j_align.at[0,'deletions'])!=0:
    #            j_motif_index -= sum((numpy.asarray(seq_j_align.at[0,'deletions'])<conserved_J_motif_index[seq_j_align.at[0,'gene_name']]))
    # print(v_motif_index)
    # print(j_motif_index)
    # Check whether the two conserved motifs have not been deleted???
    end_seq = sequence[v_motif_index:j_motif_index + 3]
    if (end_seq[0:3] != "TGT") & (end_seq[0:3] != "TGG"):
        return None
    # return "TGT not found"
    if end_seq[len(end_seq) - 3:len(end_seq)] != "TGG":
        return None
    # return "TGG not found"
    # return end_seq

    return end_seq


# return None


def find_seqs_CDR3(indexed_sequences, v_aligns, j_aligns,
                   conserved_V_motif_index, conserved_J_motif_index):
    """Returns the sequences CDR3 based on provided alignments and conserved
    motifs indices.

    """
    return indexed_sequences.apply(
        lambda x: find_seq_CDR3(x.seq_index, x.sequence, v_aligns, j_aligns,
                                conserved_V_motif_index,
                                conserved_J_motif_index), axis=1)
